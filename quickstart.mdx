---
title: Quick start
description: Build your first state machine with XState in 5 minutes
---

This guide will walk you through creating your first state machine with XState. You'll learn how to define states, handle events, and manage context.

## Prerequisites

Make sure you have XState installed:

```bash
npm install xstate
```

## Build a toggle machine

Let's create a simple toggle machine that switches between inactive and active states, and counts how many times it's been activated.

<Steps>
  <Step title="Import XState functions">
    First, import the functions you'll need from XState:

    ```typescript
    import { createMachine, createActor, assign } from 'xstate';
    ```

    - `createMachine` - Creates a state machine definition
    - `createActor` - Creates a running instance of the machine
    - `assign` - Updates the machine's context (data)
  </Step>

  <Step title="Define the state machine">
    Create a state machine with two states and a counter:

    ```typescript
    const toggleMachine = createMachine({
      id: 'toggle',
      initial: 'inactive',
      context: {
        count: 0
      },
      states: {
        inactive: {
          on: {
            TOGGLE: { target: 'active' }
          }
        },
        active: {
          entry: assign({ count: ({ context }) => context.count + 1 }),
          on: {
            TOGGLE: { target: 'inactive' }
          }
        }
      }
    });
    ```

    This machine:
    - Starts in the `inactive` state
    - Has a `count` in its context that tracks activations
    - Transitions to `active` when it receives a `TOGGLE` event
    - Increments the counter each time it enters the `active` state
    - Returns to `inactive` when it receives another `TOGGLE` event
  </Step>

  <Step title="Create an actor">
    An actor is a running instance of your state machine logic, like a store:

    ```typescript
    const toggleActor = createActor(toggleMachine);
    ```

    The actor hasn't started yet, so it won't process events until you start it.
  </Step>

  <Step title="Subscribe to state changes">
    Subscribe to the actor to receive updates when the state changes:

    ```typescript
    toggleActor.subscribe((state) => {
      console.log(state.value, state.context);
    });
    ```

    The `state` object contains:
    - `state.value` - The current state name
    - `state.context` - The current context data
  </Step>

  <Step title="Start the actor">
    Start the actor to begin processing:

    ```typescript
    toggleActor.start();
    // => logs 'inactive', { count: 0 }
    ```

    When you start the actor, it immediately emits its initial state.
  </Step>

  <Step title="Send events">
    Send events to trigger state transitions:

    ```typescript
    toggleActor.send({ type: 'TOGGLE' });
    // => logs 'active', { count: 1 }

    toggleActor.send({ type: 'TOGGLE' });
    // => logs 'inactive', { count: 1 }
    ```

    Each time you send the `TOGGLE` event:
    - The machine transitions to the next state
    - The counter increments when entering the `active` state
    - Subscribers are notified of the state change
  </Step>
</Steps>

## Complete example

Here's the complete code:

```typescript
import { createMachine, createActor, assign } from 'xstate';

// State machine
const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  context: {
    count: 0
  },
  states: {
    inactive: {
      on: {
        TOGGLE: { target: 'active' }
      }
    },
    active: {
      entry: assign({ count: ({ context }) => context.count + 1 }),
      on: {
        TOGGLE: { target: 'inactive' }
      }
    }
  }
});

// Actor (instance of the machine logic, like a store)
const toggleActor = createActor(toggleMachine);
toggleActor.subscribe((state) => console.log(state.value, state.context));
toggleActor.start();
// => logs 'inactive', { count: 0 }

toggleActor.send({ type: 'TOGGLE' });
// => logs 'active', { count: 1 }

toggleActor.send({ type: 'TOGGLE' });
// => logs 'inactive', { count: 1 }
```

## Understanding the core concepts

### States

States represent the different modes your application can be in. In this example:
- `inactive` - The toggle is off
- `active` - The toggle is on

Your machine can only be in one state at a time, which prevents impossible states.

### Events

Events trigger transitions between states. Events are objects with a `type` property:

```typescript
{ type: 'TOGGLE' }
```

### Context

Context is the data that persists across state transitions. Use `assign` to update context:

```typescript
entry: assign({ count: ({ context }) => context.count + 1 })
```

### Actors

Actors are running instances of your state machine logic. They:
- Process events
- Emit state changes
- Can be subscribed to for updates
- Can spawn other actors

<Tip>
Think of a state machine as a blueprint, and an actor as a running instance of that blueprint, similar to how a class is a blueprint and an object is an instance.
</Tip>

## Next steps

<CardGroup cols={2}>
  <Card title="Core concepts" icon="book" href="/core-concepts">
    Dive deeper into state machines and actors
  </Card>
  <Card title="State machine basics" icon="diagram-project" href="/state-machines">
    Learn about hierarchical and parallel states
  </Card>
  <Card title="Actions" icon="bolt" href="/actions">
    Execute side effects in your state machines
  </Card>
  <Card title="Stately Studio" icon="paintbrush" href="https://state.new">
    Visualize and edit your state machines
  </Card>
</CardGroup>
